; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32  -mattr=+zce-cpush-cpop -riscv-no-aliases -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=RV32I

define dso_local i32 @pushpopret0(i32 signext %size) local_unnamed_addr #0 {
; RV32I-LABEL: pushpopret0:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    .cfi_def_cfa_offset 16
; RV32I-NEXT:    cm.push {ra, s0}, -16
; RV32I-NEXT:    .cfi_offset ra, -4
; RV32I-NEXT:    .cfi_offset s0, -8
; RV32I-NEXT:    addi s0, sp, 16
; RV32I-NEXT:    .cfi_def_cfa s0, 0
; RV32I-NEXT:    addi a0, a0, 15
; RV32I-NEXT:    andi a0, a0, -16
; RV32I-NEXT:    sub a0, sp, a0
; RV32I-NEXT:    addi sp, a0, 0
; RV32I-NEXT:    call callee_void@plt
; RV32I-NEXT:    addi sp, s0, -16
; RV32I-NEXT:    cm.popretz {ra, s0}, 16
entry:
  %0 = alloca i8, i32 %size, align 16
  call void @callee_void(i8* nonnull %0)
  ret i32 0
}

define dso_local i32 @pushpopret1(i32 signext %size) local_unnamed_addr #0 {
; RV32I-LABEL: pushpopret1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    .cfi_def_cfa_offset 16
; RV32I-NEXT:    cm.push {ra, s0}, -16
; RV32I-NEXT:    .cfi_offset ra, -4
; RV32I-NEXT:    .cfi_offset s0, -8
; RV32I-NEXT:    addi s0, sp, 16
; RV32I-NEXT:    .cfi_def_cfa s0, 0
; RV32I-NEXT:    addi a0, a0, 15
; RV32I-NEXT:    andi a0, a0, -16
; RV32I-NEXT:    sub a0, sp, a0
; RV32I-NEXT:    addi sp, a0, 0
; RV32I-NEXT:    call callee_void@plt
; RV32I-NEXT:    addi a0, zero, 1
; RV32I-NEXT:    addi sp, s0, -16
; RV32I-NEXT:    cm.popretz {ra, s0}, 16
entry:
  %0 = alloca i8, i32 %size, align 16
  call void @callee_void(i8* nonnull %0)
  ret i32 1
}

define dso_local i32 @pushpopretneg1(i32 signext %size) local_unnamed_addr #0 {
; RV32I-LABEL: pushpopretneg1:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    .cfi_def_cfa_offset 16
; RV32I-NEXT:    cm.push {ra, s0}, -16
; RV32I-NEXT:    .cfi_offset ra, -4
; RV32I-NEXT:    .cfi_offset s0, -8
; RV32I-NEXT:    addi s0, sp, 16
; RV32I-NEXT:    .cfi_def_cfa s0, 0
; RV32I-NEXT:    addi a0, a0, 15
; RV32I-NEXT:    andi a0, a0, -16
; RV32I-NEXT:    sub a0, sp, a0
; RV32I-NEXT:    addi sp, a0, 0
; RV32I-NEXT:    call callee_void@plt
; RV32I-NEXT:    addi a0, zero, -1
; RV32I-NEXT:    addi sp, s0, -16
; RV32I-NEXT:    cm.popret {ra, s0}, 16
entry:
  %0 = alloca i8, i32 %size, align 16
  call void @callee_void(i8* nonnull %0)
  ret i32 -1
}

define dso_local i32 @pushpopret2(i32 signext %size) local_unnamed_addr #0 {
; RV32I-LABEL: pushpopret2:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    .cfi_def_cfa_offset 16
; RV32I-NEXT:    cm.push {ra, s0}, -16
; RV32I-NEXT:    .cfi_offset ra, -4
; RV32I-NEXT:    .cfi_offset s0, -8
; RV32I-NEXT:    addi s0, sp, 16
; RV32I-NEXT:    .cfi_def_cfa s0, 0
; RV32I-NEXT:    addi a0, a0, 15
; RV32I-NEXT:    andi a0, a0, -16
; RV32I-NEXT:    sub a0, sp, a0
; RV32I-NEXT:    addi sp, a0, 0
; RV32I-NEXT:    call callee_void@plt
; RV32I-NEXT:    addi a0, zero, 2
; RV32I-NEXT:    addi sp, s0, -16
; RV32I-NEXT:    cm.popretz {ra, s0}, 16
entry:
  %0 = alloca i8, i32 %size, align 16
  call void @callee_void(i8* nonnull %0)
  ret i32 2
}

define dso_local i32 @tailcall(i32 signext %size) local_unnamed_addr #0 {
; RV32I-LABEL: tailcall:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    .cfi_def_cfa_offset 16
; RV32I-NEXT:    cm.push {ra, s0}, -16
; RV32I-NEXT:    .cfi_offset ra, -4
; RV32I-NEXT:    .cfi_offset s0, -8
; RV32I-NEXT:    addi s0, sp, 16
; RV32I-NEXT:    .cfi_def_cfa s0, 0
; RV32I-NEXT:    addi a0, a0, 15
; RV32I-NEXT:    andi a0, a0, -16
; RV32I-NEXT:    sub a0, sp, a0
; RV32I-NEXT:    addi sp, a0, 0
; RV32I-NEXT:    addi sp, s0, -16
; RV32I-NEXT:    cm.pop {ra, s0}, 16
; RV32I-NEXT:    tail callee@plt
entry:
  %0 = alloca i8, i32 %size, align 16
  %1 = tail call i32 @callee(i8* nonnull %0)
  ret i32 %1
}

@var = global [5 x i32] zeroinitializer
define dso_local i32 @nocompress(i32 signext %size) local_unnamed_addr #0 {
; RV32I-LABEL: nocompress:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    .cfi_def_cfa_offset 48
; RV32I-NEXT:    cm.push {ra, s0-s8}, -48
; RV32I-NEXT:    .cfi_offset ra, -4
; RV32I-NEXT:    .cfi_offset s0, -8
; RV32I-NEXT:    .cfi_offset s1, -12
; RV32I-NEXT:    .cfi_offset s2, -16
; RV32I-NEXT:    .cfi_offset s3, -20
; RV32I-NEXT:    .cfi_offset s4, -24
; RV32I-NEXT:    .cfi_offset s5, -28
; RV32I-NEXT:    .cfi_offset s6, -32
; RV32I-NEXT:    .cfi_offset s7, -36
; RV32I-NEXT:    .cfi_offset s8, -40
; RV32I-NEXT:    addi s0, sp, 48
; RV32I-NEXT:    .cfi_def_cfa s0, 0
; RV32I-NEXT:    addi a0, a0, 15
; RV32I-NEXT:    andi a0, a0, -16
; RV32I-NEXT:    sub s2, sp, a0
; RV32I-NEXT:    addi sp, s2, 0
; RV32I-NEXT:    lui s1, %hi(var)
; RV32I-NEXT:    lw s3, %lo(var)(s1)
; RV32I-NEXT:    lw s4, %lo(var+4)(s1)
; RV32I-NEXT:    lw s5, %lo(var+8)(s1)
; RV32I-NEXT:    lw s6, %lo(var+12)(s1)
; RV32I-NEXT:    addi s7, s1, %lo(var)
; RV32I-NEXT:    lw s8, 16(s7)
; RV32I-NEXT:    addi a0, s2, 0
; RV32I-NEXT:    call callee_void@plt
; RV32I-NEXT:    sw s8, 16(s7)
; RV32I-NEXT:    sw s6, %lo(var+12)(s1)
; RV32I-NEXT:    sw s5, %lo(var+8)(s1)
; RV32I-NEXT:    sw s4, %lo(var+4)(s1)
; RV32I-NEXT:    sw s3, %lo(var)(s1)
; RV32I-NEXT:    addi a0, s2, 0
; RV32I-NEXT:    addi sp, s0, -48
; RV32I-NEXT:    cm.pop {ra, s0-s8}, 48
; RV32I-NEXT:    tail callee@plt
entry:
  %0 = alloca i8, i32 %size, align 16
  %val = load [5 x i32], [5 x i32]* @var
  call void @callee_void(i8* nonnull %0)
  store volatile [5 x i32] %val, [5 x i32]* @var
  %1 = tail call i32 @callee(i8* nonnull %0)
  ret i32 %1
}

declare void @callee_void(i8*)
declare i32 @callee(i8*)

