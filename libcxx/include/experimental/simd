// -*- C++ -*-
//===------------------------------- simd ---------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#ifndef _LIBCPP_EXPERIMENTAL_SIMD
#define _LIBCPP_EXPERIMENTAL_SIMD

#define __cpp_lib_experimental_parallel_simd 201803

/*
    experimental/simd synopsis

namespace std::experimental {

inline namespace parallelism_v2 {

namespace simd_abi {

struct scalar {};
template <int N> struct fixed_size {};
template <typename T> inline constexpr int max_fixed_size = implementation-defined;
template <typename T> using compatible = implementation-defined;
template <typename T> using native = implementation-defined;

template <class T, size_t N, class... Abis> struct deduce { using type = see below; };
template <class T, size_t N, class... Abis> using deduce_t =
  typename deduce<T, N>::type;

} // simd_abi

struct element_aligned_tag {};
struct vector_aligned_tag {};
template <size_t> struct overaligned_tag {};
inline constexpr element_aligned_tag element_aligned{};
inline constexpr vector_aligned_tag vector_aligned{};
template <size_t N> inline constexpr overaligned_tag<N> overaligned{};

// 9.4, simd type traits
template <class T> struct is_abi_tag;
template <class T> inline constexpr bool is_abi_tag_v = is_abi_tag<T>::value;

template <class T> struct is_simd;
template <class T> inline constexpr bool is_simd_v = is_simd<T>::value;

template <class T> struct is_simd_mask;
template <class T> inline constexpr bool is_simd_mask_v = is_simd_mask<T>::value;

template <class T> struct is_simd_flag_type;
template <class T> inline constexpr bool is_simd_flag_type_v =
  is_simd_flag_type<T>::value;

template <class T, class Abi = simd_abi::compatible<T>> struct simd_size;
template <class T, class Abi = simd_abi::compatible<T>>
  inline constexpr size_t simd_size_v = simd_size<T, Abi>::value;

template <class T, class U = typename T::value_type> struct memory_alignment;
template <class T, class U = typename T::value_type>
  inline constexpr size_t memory_alignment_v = memory_alignment<T, U>::value;

template<class T, class V> struct rebind_simd { using type = see below; };
template<class T, class V> using rebind_simd_t = typename rebind_simd<T, V>::type;
template<int N, class V> struct resize_simd { using type = see below; };
template<int N, class V> using resize_simd_t = typename resize_simd<N, V>::type;

// 9.6, Class template simd
template <class T, class Abi = simd_abi::compatible<T>> class simd;
template <class T> using native_simd = simd<T, simd_abi::native<T>>;
template <class T, int N> using fixed_size_simd = simd<T, simd_abi::fixed_size<N>>;

// 9.8, Class template simd_mask
template <class T, class Abi = simd_abi::compatible<T>> class simd_mask;
template <class T> using native_simd_mask = simd_mask<T, simd_abi::native<T>>;
template <class T, int N> using fixed_size_simd_mask =
  simd_mask<T, simd_abi::fixed_size<N>>;

// 9.7.5, Casts
template <class T, class U, class Abi> see below simd_cast(const simd<U, Abi>&) noexcept;
template <class T, class U, class Abi> see below static_simd_cast(const simd<U, Abi>&) noexcept;

template <class T, class Abi>
  fixed_size_simd<T, simd_size_v<T, Abi>>
    to_fixed_size(const simd<T, Abi>&) noexcept;
template <class T, class Abi>
  fixed_size_simd_mask<T, simd_size_v<T, Abi>>
    to_fixed_size(const simd_mask<T, Abi>&) noexcept;
template <class T, size_t N>
  native_simd<T> to_native(const fixed_size_simd<T, N>&) noexcept;
template <class T, size_t N>
  native_simd_mask<T> to_native(const fixed_size_simd_mask<T, N>> &) noexcept;
template <class T, size_t N>
  simd<T> to_compatible(const fixed_size_simd<T, N>&) noexcept;
template <class T, size_t N>
  simd_mask<T> to_compatible(const fixed_size_simd_mask<T, N>&) noexcept;

template <size_t... Sizes, class T, class Abi>
  tuple<simd<T, simd_abi::deduce_t<T, Sizes>>...>
    split(const simd<T, Abi>&);
template <size_t... Sizes, class T, class Abi>
  tuple<simd_mask<T, simd_mask_abi::deduce_t<T, Sizes>>...>
    split(const simd_mask<T, Abi>&);
template <class V, class Abi>
  array<V, simd_size_v<typename V::value_type, Abi> / V::size()>
    split(const simd<typename V::value_type, Abi>&) noexcept;
template <class V, class Abi>
  array<V, simd_size_v<typename V::value_type, Abi> / V::size()>
    split(const simd_mask<typename V::simd_type::value_type, Abi>&) noexcept;

template<size_t N, class T, class A>
  array<resize_simd<simd_size_v<T, A> / N, simd<T, A>>, N>
    split_by(const simd<T, A>& x) noexcept;
template<size_t N, class T, class A>
  array<resize_simd<simd_size_v<T, A> / N, simd_mask<T, A>>, N>
    split_by(const simd_mask<T, A>& x) noexcept;

template<class T, class... Abis>
  simd<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>>
    concat(const simd<T, Abis>&...) noexcept;
template<class T, class... Abis>
  simd_mask<T, simd_abi::deduce_t<T, (simd_size_v<T, Abis> + ...)>>
    concat(const simd_mask<T, Abis>&...) noexcept;

template<class T, class Abi, size_t N>
  resize_simd<simd_size_v<T, Abi> * N, simd<T, Abi>>
    concat(const array<simd<T, Abi>, N>& arr) noexcept;
template<class T, class Abi, size_t N>
  resize_simd<simd_size_v<T, Abi> * N, simd_mask<T, Abi>>
    concat(const array<simd_mask<T, Abi>, N>& arr) noexcept;

// 9.9.4, reductions
template <class T, class Abi> bool all_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> bool any_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> bool none_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> bool some_of(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> int popcount(const simd_mask<T, Abi>&) noexcept;
template <class T, class Abi> int find_first_set(const simd_mask<T, Abi>&);
template <class T, class Abi> int find_last_set(const simd_mask<T, Abi>&);

bool all_of(T) noexcept;
bool any_of(T) noexcept;
bool none_of(T) noexcept;
bool some_of(T) noexcept;
int popcount(T) noexcept;
int find_first_set(T);
int find_last_set(T);

// 9.5, Where expression class templates
template <class M, class T> class const_where_expression;
template <class M, class T> class where_expression;

// 9.9.5, Where functions
template <class T, class Abi>
  where_expression<simd_mask<T, Abi>, simd<T, Abi>>
    where(const typename simd<T, Abi>::mask_type&, simd<T, Abi>&) noexcept;

template <class T, class Abi>
  const_where_expression<simd_mask<T, Abi>, const simd<T, Abi>>
    where(const typename simd<T, Abi>::mask_type&, const simd<T, Abi>&) noexcept;

template <class T, class Abi>
  where_expression<simd_mask<T, Abi>, simd_mask<T, Abi>>
    where(const type_identity_t<simd_mask<T, Abi>>&, simd_mask<T, Abi>&) noexcept;

template <class T, class Abi>
  const_where_expression<simd_mask<T, Abi>, const simd_mask<T, Abi>>
    where(const type_identity_t<simd_mask<T, Abi>>&, const simd_mask<T, Abi>&) noexcept;

template <class T>
  where_expression<bool, T>
    where(see below k, T& d) noexcept;

template <class T>
  const_where_expression<bool, T>
    where(see below k, const T& d) noexcept;

// 9.7.4, Reductions
template <class T, class Abi, class BinaryOperation = plus<>>
  T reduce(const simd<T, Abi>&,
           BinaryOperation = {});
template <class M, class V, class BinaryOperation>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                typename V::value_type neutral_element,
                                BinaryOperation binary_op);
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                plus<> binary_op = {}) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                multiplies<> binary_op) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                bit_and<> binary_op) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                bit_or<> binary_op) noexcept;
template <class M, class V>
  typename V::value_type reduce(const const_where_expression<M, V>& x,
                                bit_xor<> binary_op) noexcept;

template <class T, class Abi>
  T hmin(const simd<T, Abi>&) noexcept;
template <class M, class V>
  typename V::value_type hmin(const const_where_expression<M, V>&) noexcept;
template <class T, class Abi>
  T hmax(const simd<T, Abi>&) noexcept;
template <class M, class V>
  typename V::value_type hmax(const const_where_expression<M, V>&) noexcept;

// 9.7.6, Algorithms
template <class T, class Abi>
  simd<T, Abi>
    min(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
template <class T, class Abi>
  simd<T, Abi>
    max(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
template <class T, class Abi>
  pair<simd<T, Abi>, simd<T, Abi>>
    minmax(const simd<T, Abi>& a, const simd<T, Abi>& b) noexcept;
template <class T, class Abi>
  simd<T, Abi>
    clamp(const simd<T, Abi>& v,
          const simd<T, Abi>& lo,
          const simd<T, Abi>& hi);

// 9.5, Where expression class templates [simd.whereexpr]
template <class M, class T> class const_where_expression {
  const M mask; // exposition only
  T& data;      // exposition only
public:
  const_where_expression(const const_where_expression&) = delete;
  const_where_expression& operator=(const const_where_expression&) = delete;

  T operator-() const && noexcept;
  T operator+() const && noexcept;
  T operator~() const && noexcept;

  template <class U, class Flags> void copy_to(U* mem, Flags f) const &&;
};

template <class M, class T>
class where_expression : public const_where_expression<M, T> {
public:
  template <class U> void operator=(U&& x) noexcept;
  template <class U> void operator+=(U&& x) noexcept;
  template <class U> void operator-=(U&& x) noexcept;
  template <class U> void operator*=(U&& x) noexcept;
  template <class U> void operator/=(U&& x) noexcept;
  template <class U> void operator%=(U&& x) noexcept;
  template <class U> void operator&=(U&& x) noexcept;
  template <class U> void operator|=(U&& x) noexcept;
  template <class U> void operator^=(U&& x) noexcept;
  template <class U> void operator<<=(U&& x) noexcept;
  template <class U> void operator>>=(U&& x) noexcept;

  void operator++() && noexcept;
  void operator++(int) && noexcept;
  void operator--() && noexcept;
  void operator--(int) && noexcept;

  template <class U, class Flags> void copy_from(const U* mem, Flags) &&;
};

// 9.6.1, Class template simd overview [simd.class.overview]
template <class T, class Abi> class simd {
public:
  using value_type = T;
  using reference = see below;
  using mask_type = simd_mask<T, Abi>;
  using abi_type = Abi;

  static constexpr size_t size() noexcept;

  simd() noexcept = default;

  // 9.6.4, simd constructors
  template <class U> simd(U&& value) noexcept;
  template <class U> simd(const simd<U, simd_abi::fixed_size<size()>>&) noexcept;
  template <class G> explicit simd(G&& gen) noexcept;
  template <class U, class Flags> simd(const U* mem, Flags f);

  // 9.6.5, simd copy functions
  template <class U, class Flags> void copy_from(const U* mem, Flags f);
  template <class U, class Flags> void copy_to(U* mem, Flags f);

  // 9.6.6, simd subscript operators
  reference operator[](size_t);
  value_type operator[](size_t) const;

  // 9.6.7, simd unary operators
  simd& operator++() noexcept;
  simd operator++(int) noexcept;
  simd& operator--() noexcept;
  simd operator--(int) noexcept;
  mask_type operator!() const noexcept;
  simd operator~() const noexcept;
  simd operator+() const noexcept;
  simd operator-() const noexcept;

  // 9.7.1, simd binary operators
  friend simd operator+ (const simd&, const simd&) noexcept;
  friend simd operator- (const simd&, const simd&) noexcept;
  friend simd operator* (const simd&, const simd&) noexcept;
  friend simd operator/ (const simd&, const simd&) noexcept;
  friend simd operator% (const simd&, const simd&) noexcept;
  friend simd operator& (const simd&, const simd&) noexcept;
  friend simd operator| (const simd&, const simd&) noexcept;
  friend simd operator^ (const simd&, const simd&) noexcept;
  friend simd operator<<(const simd&, const simd&) noexcept;
  friend simd operator>>(const simd&, const simd&) noexcept;
  friend simd operator<<(const simd&, int) noexcept;
  friend simd operator>>(const simd&, int) noexcept;

  // 9.7.2, simd compound assignment
  friend simd& operator+= (simd&, const simd&) noexcept;
  friend simd& operator-= (simd&, const simd&) noexcept;
  friend simd& operator*= (simd&, const simd&) noexcept;
  friend simd& operator/= (simd&, const simd&) noexcept;
  friend simd& operator%= (simd&, const simd&) noexcept;
  friend simd& operator&= (simd&, const simd&) noexcept;
  friend simd& operator|= (simd&, const simd&) noexcept;
  friend simd& operator^= (simd&, const simd&) noexcept;
  friend simd& operator<<=(simd&, const simd&) noexcept;
  friend simd& operator>>=(simd&, const simd&) noexcept;
  friend simd& operator<<=(simd&, int) noexcept;
  friend simd& operator>>=(simd&, int) noexcept;

  // 9.7.3, simd compare operators
  friend mask_type operator==(const simd&, const simd&) noexcept;
  friend mask_type operator!=(const simd&, const simd&) noexcept;
  friend mask_type operator>=(const simd&, const simd&) noexcept;
  friend mask_type operator<=(const simd&, const simd&) noexcept;
  friend mask_type operator> (const simd&, const simd&) noexcept;
  friend mask_type operator< (const simd&, const simd&) noexcept;
};

// 9.7.7, Math library [simd.math]
template <class Abi> using scharv = simd<signed char, Abi>; // exposition only
template <class Abi> using shortv = simd<short, Abi>; // exposition only
template <class Abi> using intv = simd<int, Abi>; // exposition only
template <class Abi> using longv = simd<long int, Abi>; // exposition only
template <class Abi> using llongv = simd<long long int, Abi>; // exposition only
template <class Abi> using floatv = simd<float, Abi>; // exposition only
template <class Abi> using doublev = simd<double, Abi>; // exposition only
template <class Abi> using ldoublev = simd<long double, Abi>; // exposition only
template <class T, class V> using samesize = fixed_size_simd<T, V::size()>; // exposition only

template <class Abi> floatv<Abi> acos(floatv<Abi> x);
template <class Abi> doublev<Abi> acos(doublev<Abi> x);
template <class Abi> ldoublev<Abi> acos(ldoublev<Abi> x);

template <class Abi> floatv<Abi> asin(floatv<Abi> x);
template <class Abi> doublev<Abi> asin(doublev<Abi> x);
template <class Abi> ldoublev<Abi> asin(ldoublev<Abi> x);

template <class Abi> floatv<Abi> atan(floatv<Abi> x);
template <class Abi> doublev<Abi> atan(doublev<Abi> x);
template <class Abi> ldoublev<Abi> atan(ldoublev<Abi> x);

template <class Abi> floatv<Abi> atan2(floatv<Abi> y, floatv<Abi> x);
template <class Abi> doublev<Abi> atan2(doublev<Abi> y, doublev<Abi> x);
template <class Abi> ldoublev<Abi> atan2(ldoublev<Abi> y, ldoublev<Abi> x);

template <class Abi> floatv<Abi> cos(floatv<Abi> x);
template <class Abi> doublev<Abi> cos(doublev<Abi> x);
template <class Abi> ldoublev<Abi> cos(ldoublev<Abi> x);

template <class Abi> floatv<Abi> sin(floatv<Abi> x);
template <class Abi> doublev<Abi> sin(doublev<Abi> x);
template <class Abi> ldoublev<Abi> sin(ldoublev<Abi> x);

template <class Abi> floatv<Abi> tan(floatv<Abi> x);
template <class Abi> doublev<Abi> tan(doublev<Abi> x);
template <class Abi> ldoublev<Abi> tan(ldoublev<Abi> x);

template <class Abi> floatv<Abi> acosh(floatv<Abi> x);
template <class Abi> doublev<Abi> acosh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> acosh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> asinh(floatv<Abi> x);
template <class Abi> doublev<Abi> asinh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> asinh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> atanh(floatv<Abi> x);
template <class Abi> doublev<Abi> atanh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> atanh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> cosh(floatv<Abi> x);
template <class Abi> doublev<Abi> cosh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> cosh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> sinh(floatv<Abi> x);
template <class Abi> doublev<Abi> sinh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> sinh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> tanh(floatv<Abi> x);
template <class Abi> doublev<Abi> tanh(doublev<Abi> x);
template <class Abi> ldoublev<Abi> tanh(ldoublev<Abi> x);

template <class Abi> floatv<Abi> exp(floatv<Abi> x);
template <class Abi> doublev<Abi> exp(doublev<Abi> x);
template <class Abi> ldoublev<Abi> exp(ldoublev<Abi> x);

template <class Abi> floatv<Abi> exp2(floatv<Abi> x);
template <class Abi> doublev<Abi> exp2(doublev<Abi> x);
template <class Abi> ldoublev<Abi> exp2(ldoublev<Abi> x);

template <class Abi> floatv<Abi> expm1(floatv<Abi> x);
template <class Abi> doublev<Abi> expm1(doublev<Abi> x);
template <class Abi> ldoublev<Abi> expm1(ldoublev<Abi> x);

template <class Abi> floatv<Abi> frexp(floatv<Abi> value, samesize<int, floatv<Abi>>* exp);
template <class Abi> doublev<Abi> frexp(doublev<Abi> value, samesize<int, doublev<Abi>>* exp);
template <class Abi> ldoublev<Abi> frexp(ldoublev<Abi> value, samesize<int, ldoublev<Abi>>* exp);

template <class Abi> samesize<int, floatv<Abi>> ilogb(floatv<Abi> x);
template <class Abi> samesize<int, doublev<Abi>> ilogb(doublev<Abi> x);
template <class Abi> samesize<int, ldoublev<Abi>> ilogb(ldoublev<Abi> x);

template <class Abi> floatv<Abi> ldexp(floatv<Abi> x, samesize<int, floatv<Abi>> exp);
template <class Abi> doublev<Abi> ldexp(doublev<Abi> x, samesize<int, doublev<Abi>> exp);
template <class Abi> ldoublev<Abi> ldexp(ldoublev<Abi> x, samesize<int, ldoublev<Abi>> exp);

template <class Abi> floatv<Abi> log(floatv<Abi> x);
template <class Abi> doublev<Abi> log(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log(ldoublev<Abi> x);

template <class Abi> floatv<Abi> log10(floatv<Abi> x);
template <class Abi> doublev<Abi> log10(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log10(ldoublev<Abi> x);

template <class Abi> floatv<Abi> log1p(floatv<Abi> x);
template <class Abi> doublev<Abi> log1p(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log1p(ldoublev<Abi> x);

template <class Abi> floatv<Abi> log2(floatv<Abi> x);
template <class Abi> doublev<Abi> log2(doublev<Abi> x);
template <class Abi> ldoublev<Abi> log2(ldoublev<Abi> x);

template <class Abi> floatv<Abi> logb(floatv<Abi> x);
template <class Abi> doublev<Abi> logb(doublev<Abi> x);
template <class Abi> ldoublev<Abi> logb(ldoublev<Abi> x);

template <class Abi> floatv<Abi> modf(floatv<Abi> value, floatv<Abi>* iptr);
template <class Abi> doublev<Abi> modf(doublev<Abi> value, doublev<Abi>* iptr);
template <class Abi> ldoublev<Abi> modf(ldoublev<Abi> value, ldoublev<Abi>* iptr);

template <class Abi> floatv<Abi> scalbn(floatv<Abi> x, samesize<int, floatv<Abi>> n);
template <class Abi> doublev<Abi> scalbn(doublev<Abi> x, samesize<int, doublev<Abi>> n);
template <class Abi> ldoublev<Abi> scalbn(ldoublev<Abi> x, samesize<int, ldoublev<Abi>> n);
template <class Abi> floatv<Abi> scalbln(floatv<Abi> x, samesize<long int, floatv<Abi>> n);
template <class Abi> doublev<Abi> scalbln(doublev<Abi> x, samesize<long int, doublev<Abi>> n);
template <class Abi> ldoublev<Abi> scalbln(ldoublev<Abi> x, samesize<long int, ldoublev<Abi>> n);

template <class Abi> floatv<Abi> cbrt(floatv<Abi> x);
template <class Abi> doublev<Abi> cbrt(doublev<Abi> x);
template <class Abi> ldoublev<Abi> cbrt(ldoublev<Abi> x);

template <class Abi> scharv<Abi> abs(scharv<Abi> j);
template <class Abi> shortv<Abi> abs(shortv<Abi> j);
template <class Abi> intv<Abi> abs(intv<Abi> j);
template <class Abi> longv<Abi> abs(longv<Abi> j);
template <class Abi> llongv<Abi> abs(llongv<Abi> j);
template <class Abi> floatv<Abi> abs(floatv<Abi> j);
template <class Abi> doublev<Abi> abs(doublev<Abi> j);
template <class Abi> ldoublev<Abi> abs(ldoublev<Abi> j);

template <class Abi> floatv<Abi> hypot(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> hypot(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> hypot(doublev<Abi> x, doublev<Abi> y);
template <class Abi> floatv<Abi> hypot(floatv<Abi> x, floatv<Abi> y, floatv<Abi> z);
template <class Abi> doublev<Abi> hypot(doublev<Abi> x, doublev<Abi> y, doublev<Abi> z);
template <class Abi> ldoublev<Abi> hypot(ldoublev<Abi> x, ldoublev<Abi> y, ldoublev<Abi> z);

template <class Abi> floatv<Abi> pow(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> pow(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> pow(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> sqrt(floatv<Abi> x);
template <class Abi> doublev<Abi> sqrt(doublev<Abi> x);
template <class Abi> ldoublev<Abi> sqrt(ldoublev<Abi> x);

template <class Abi> floatv<Abi> erf(floatv<Abi> x);
template <class Abi> doublev<Abi> erf(doublev<Abi> x);
template <class Abi> ldoublev<Abi> erf(ldoublev<Abi> x);
template <class Abi> floatv<Abi> erfc(floatv<Abi> x);
template <class Abi> doublev<Abi> erfc(doublev<Abi> x);
template <class Abi> ldoublev<Abi> erfc(ldoublev<Abi> x);

template <class Abi> floatv<Abi> lgamma(floatv<Abi> x);
template <class Abi> doublev<Abi> lgamma(doublev<Abi> x);
template <class Abi> ldoublev<Abi> lgamma(ldoublev<Abi> x);

template <class Abi> floatv<Abi> tgamma(floatv<Abi> x);
template <class Abi> doublev<Abi> tgamma(doublev<Abi> x);
template <class Abi> ldoublev<Abi> tgamma(ldoublev<Abi> x);

template <class Abi> floatv<Abi> ceil(floatv<Abi> x);
template <class Abi> doublev<Abi> ceil(doublev<Abi> x);
template <class Abi> ldoublev<Abi> ceil(ldoublev<Abi> x);

template <class Abi> floatv<Abi> floor(floatv<Abi> x);
template <class Abi> doublev<Abi> floor(doublev<Abi> x);
template <class Abi> ldoublev<Abi> floor(ldoublev<Abi> x);

template <class Abi> floatv<Abi> nearbyint(floatv<Abi> x);
template <class Abi> doublev<Abi> nearbyint(doublev<Abi> x);
template <class Abi> ldoublev<Abi> nearbyint(ldoublev<Abi> x);

template <class Abi> floatv<Abi> rint(floatv<Abi> x);
template <class Abi> doublev<Abi> rint(doublev<Abi> x);
template <class Abi> ldoublev<Abi> rint(ldoublev<Abi> x);

template <class Abi> samesize<long int, floatv<Abi>> lrint(floatv<Abi> x);
template <class Abi> samesize<long int, doublev<Abi>> lrint(doublev<Abi> x);
template <class Abi> samesize<long int, ldoublev<Abi>> lrint(ldoublev<Abi> x);
template <class Abi> samesize<long long int, floatv<Abi>> llrint(floatv<Abi> x);
template <class Abi> samesize<long long int, doublev<Abi>> llrint(doublev<Abi> x);
template <class Abi> samesize<long long int, ldoublev<Abi>> llrint(ldoublev<Abi> x);

template <class Abi> floatv<Abi> round(floatv<Abi> x);
template <class Abi> doublev<Abi> round(doublev<Abi> x);
template <class Abi> ldoublev<Abi> round(ldoublev<Abi> x);
template <class Abi> samesize<long int, floatv<Abi>> lround(floatv<Abi> x);
template <class Abi> samesize<long int, doublev<Abi>> lround(doublev<Abi> x);
template <class Abi> samesize<long int, ldoublev<Abi>> lround(ldoublev<Abi> x);
template <class Abi> samesize<long long int, floatv<Abi>> llround(floatv<Abi> x);
template <class Abi> samesize<long long int, doublev<Abi>> llround(doublev<Abi> x);
template <class Abi> samesize<long long int, ldoublev<Abi>> llround(ldoublev<Abi> x);

template <class Abi> floatv<Abi> trunc(floatv<Abi> x);
template <class Abi> doublev<Abi> trunc(doublev<Abi> x);
template <class Abi> ldoublev<Abi> trunc(ldoublev<Abi> x);

template <class Abi> floatv<Abi> fmod(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fmod(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fmod(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> remainder(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> remainder(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> remainder(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> remquo(floatv<Abi> x, floatv<Abi> y, samesize<int, floatv<Abi>>* quo);
template <class Abi> doublev<Abi> remquo(doublev<Abi> x, doublev<Abi> y, samesize<int, doublev<Abi>>* quo);
template <class Abi> ldoublev<Abi> remquo(ldoublev<Abi> x, ldoublev<Abi> y, samesize<int, ldoublev<Abi>>* quo);

template <class Abi> floatv<Abi> copysign(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> copysign(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> copysign(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> doublev<Abi> nan(const char* tagp);
template <class Abi> floatv<Abi> nanf(const char* tagp);
template <class Abi> ldoublev<Abi> nanl(const char* tagp);

template <class Abi> floatv<Abi> nextafter(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> nextafter(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> nextafter(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> nexttoward(floatv<Abi> x, ldoublev<Abi> y);
template <class Abi> doublev<Abi> nexttoward(doublev<Abi> x, ldoublev<Abi> y);
template <class Abi> ldoublev<Abi> nexttoward(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fdim(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fdim(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fdim(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fmax(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fmax(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fmax(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fmin(floatv<Abi> x, floatv<Abi> y);
template <class Abi> doublev<Abi> fmin(doublev<Abi> x, doublev<Abi> y);
template <class Abi> ldoublev<Abi> fmin(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> floatv<Abi> fma(floatv<Abi> x, floatv<Abi> y, floatv<Abi> z);
template <class Abi> doublev<Abi> fma(doublev<Abi> x, doublev<Abi> y, doublev<Abi> z);
template <class Abi> ldoublev<Abi> fma(ldoublev<Abi> x, ldoublev<Abi> y, ldoublev<Abi> z);

template <class Abi> samesize<int, floatv<Abi>> fpclassify(floatv<Abi> x);
template <class Abi> samesize<int, doublev<Abi>> fpclassify(doublev<Abi> x);
template <class Abi> samesize<int, ldoublev<Abi>> fpclassify(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isfinite(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isfinite(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isfinite(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isinf(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isinf(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isinf(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isnan(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isnan(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isnan(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isnormal(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> isnormal(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> isnormal(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> signbit(floatv<Abi> x);
template <class Abi> simd_mask<double, Abi> signbit(doublev<Abi> x);
template <class Abi> simd_mask<long double, Abi> signbit(ldoublev<Abi> x);

template <class Abi> simd_mask<float, Abi> isgreater(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isgreater(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isgreater(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> isgreaterequal(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isgreaterequal(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isgreaterequal(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> isless(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isless(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isless(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> islessequal(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> islessequal(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> islessequal(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> islessgreater(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> islessgreater(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> islessgreater(ldoublev<Abi> x, ldoublev<Abi> y);

template <class Abi> simd_mask<float, Abi> isunordered(floatv<Abi> x, floatv<Abi> y);
template <class Abi> simd_mask<double, Abi> isunordered(doublev<Abi> x, doublev<Abi> y);
template <class Abi> simd_mask<long double, Abi> isunordered(ldoublev<Abi> x, ldoublev<Abi> y);

template <class V> struct simd_div_t { V quot, rem; };
template <class Abi> simd_div_t<scharv<Abi>> div(scharv<Abi> numer, scharv<Abi> denom);
template <class Abi> simd_div_t<shortv<Abi>> div(shortv<Abi> numer, shortv<Abi> denom);
template <class Abi> simd_div_t<intv<Abi>> div(intv<Abi> numer, intv<Abi> denom);
template <class Abi> simd_div_t<longv<Abi>> div(longv<Abi> numer, longv<Abi> denom);
template <class Abi> simd_div_t<llongv<Abi>> div(llongv<Abi> numer, llongv<Abi> denom);

// 9.8.1, Class template simd_mask overview [simd.mask.overview]
template <class T, class Abi> class simd_mask {
public:
  using value_type = bool;
  using reference = see below;
  using simd_type = simd<T, Abi>;
  using abi_type = Abi;

  static constexpr size_t size() noexcept;

  simd_mask() noexcept = default;

  // 9.8.3, Constructors
  explicit simd_mask(value_type) noexcept;
  template <class U>
    simd_mask(const simd_mask<U, simd_abi::fixed_size<size()>>&) noexcept;
  template <class Flags> simd_mask(const value_type* mem, Flags);

  // 9.8.4, Copy functions
  template <class Flags> void copy_from(const value_type* mem, Flags);
  template <class Flags> void copy_to(value_type* mem, Flags) const;

  // 9.8.5, Subscript operators
  reference operator[](size_t);
  value_type operator[](size_t) const;

  // 9.8.6, Unary operators
  simd_mask operator!() const noexcept;

  // 9.9.1, Binary operators
  friend simd_mask operator&&(const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator||(const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator& (const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator| (const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator^ (const simd_mask&, const simd_mask&) noexcept;

  // 9.9.2, Compound assignment
  friend simd_mask& operator&=(simd_mask&, const simd_mask&) noexcept;
  friend simd_mask& operator|=(simd_mask&, const simd_mask&) noexcept;
  friend simd_mask& operator^=(simd_mask&, const simd_mask&) noexcept;

  // 9.9.3, Comparisons
  friend simd_mask operator==(const simd_mask&, const simd_mask&) noexcept;
  friend simd_mask operator!=(const simd_mask&, const simd_mask&) noexcept;
};

} // parallelism_v2
} // std::experimental

*/

#include <experimental/__config>
#include <cstddef>
#include <functional>
#include <type_traits>
#include <utility>
#include <__simd/builtin.h>
#include <__simd/config.h>
#include <__simd/scalar.h>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_SIMD

#if _LIBCPP_STD_VER >= 17

// TODO: handle _LIBCPP_HAS_NO_VECTOR_EXTENSION

template <class _Storage, class _ValueType>
class __simd_reference {
  template <class, class>
  friend class simd;

  template <class, class>
  friend class simd_mask;

  _Storage& __s_;
  size_t __idx_;

  __simd_reference(_Storage& __s, size_t __idx) : __s_(__s), __idx_(__idx) {}

  _ValueType __get() const { return __s_.__get(__idx_); }

  void __set(_ValueType __v) {
    if constexpr (std::is_same_v<_ValueType, bool>)
      __s_.__set(__idx_, __set_all_bits<decltype(__s_.__data[0])>(__v));
    else
      __s_.__set(__idx_, __v);
  }

public:
  using value_type = _ValueType;

  __simd_reference() = delete;
  __simd_reference(const __simd_reference&) = delete;

  operator value_type() const noexcept { return __get(); }

  template<class _Up>
  enable_if_t<is_void_v<void_t<decltype(declval<value_type&>() = declval<_Up>())>>, __simd_reference>
  operator=(_Up&& __v) && noexcept {
    __set(static_cast<value_type>(std::forward<_Up>(__v)));
    return {__s_, __idx_};
  }

#define _LIBCXX_SIMD_REFERENCE_OP_(__op)                                                                  \
  template<class _Up>                                                                                     \
  enable_if_t<is_void_v<void_t<decltype(declval<value_type&>() __op declval<_Up>())>>, __simd_reference>  \
  operator __op##=(_Up&& __v) && noexcept {                                                               \
    __set(__get() __op static_cast<value_type>(std::forward<_Up>(__v)));                                  \
    return {__s_, __idx_};                                                                                \
  }
  _LIBCXX_SIMD_REFERENCE_OP_(+)
  _LIBCXX_SIMD_REFERENCE_OP_(-)
  _LIBCXX_SIMD_REFERENCE_OP_(*)
  _LIBCXX_SIMD_REFERENCE_OP_(/)
  _LIBCXX_SIMD_REFERENCE_OP_(%)
  _LIBCXX_SIMD_REFERENCE_OP_(^)
  _LIBCXX_SIMD_REFERENCE_OP_(<<)
  _LIBCXX_SIMD_REFERENCE_OP_(>>)
#undef _LIBCXX_SIMD_REFERENCE_OP_

  template<class _Up>
  enable_if_t<is_void_v<void_t<decltype(declval<value_type&>() &= declval<_Up>())>>, __simd_reference>
  operator &=(_Up&& __v) && noexcept {
    if constexpr (std::is_same_v<_ValueType, bool>)
      __set(__get() && static_cast<value_type>(std::forward<_Up>(__v)));
    else
      __set(__get() & static_cast<value_type>(std::forward<_Up>(__v)));
    return {__s_, __idx_};
  }

  template<class _Up>
  enable_if_t<is_void_v<void_t<decltype(declval<value_type&>() |= declval<_Up>())>>, __simd_reference>
  operator |=(_Up&& __v) && noexcept {
    if constexpr (std::is_same_v<_ValueType, bool>)
      __set(__get() || static_cast<value_type>(std::forward<_Up>(__v)));
    else
      __set(__get() | static_cast<value_type>(std::forward<_Up>(__v)));
    return {__s_, __idx_};
  }

  template <class _Up = void, class = decltype(++declval<conditional_t<true, value_type, _Up>&>())>
  __simd_reference operator++() && noexcept {
    __set(__get() + 1);
    return {__s_, __idx_};
  }

  template <class _Up = void, class = decltype(declval<conditional_t<true, value_type, _Up>&>()++)>
  value_type operator++(int) && noexcept {
    auto __r = __get();
    __set(__get() + 1);
    return __r;
  }

  template <class _Up = void, class = decltype(--declval<conditional_t<true, value_type, _Up>&>())>
  __simd_reference operator--() && noexcept {
    __set(__get() - 1);
    return {__s_, __idx_};
  }

  template <class _Up = void, class = decltype(declval<conditional_t<true, value_type, _Up>&>()--)>
  value_type operator--(int) && noexcept {
    auto __r = __get();
    __set(__get() - 1);
    return __r;
  }

  friend void swap(__simd_reference&& __a, __simd_reference&& __b) noexcept {
    value_type __tmp = static_cast<__simd_reference&&>(__a);
    static_cast<__simd_reference&&>(__a) = static_cast<value_type>(__b);
    static_cast<__simd_reference&&>(__b) = std::move(__tmp);
  }

  friend void swap(value_type& __a, __simd_reference&& __b) noexcept {
    value_type __tmp(std::move(__a));
    __a = static_cast<value_type>(__b);
    static_cast<__simd_reference&&>(__b) = std::move(__tmp);
  }

  friend void swap(__simd_reference&& __a, value_type& __b) noexcept {
    value_type __tmp(__a);
    static_cast<__simd_reference&&>(__a) = std::move(__b);
    __b = std::move(__tmp);
  }
};

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_SIMD

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_SIMD_ABI
// TODO: Elaboration of implementation-defined ABIs

using scalar = __scalar;

template <class _Tp>
inline constexpr size_t max_fixed_size = 32;

template <int _Np>
using fixed_size = __builtin<_Np>;
template <class _Tp>
using compatible = __builtin<16 / sizeof(_Tp)>;
#if defined(__AVX__)
template <class _Tp>
using native = __builtin<_LIBCPP_NATIVE_SIMD_WIDTH_IN_BYTES / sizeof(_Tp)>;
#else
template <class _Tp>
using native = __builtin<16 / sizeof(_Tp)>;
#endif

template <class _Tp, size_t _Np, class... Abis>
struct deduce {
  using type = fixed_size<_Np>;
};

template <class _Tp, size_t _Np, class... Abis>
using deduce_t = typename deduce<_Tp, _Np>::type;

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_SIMD_ABI

_LIBCPP_BEGIN_NAMESPACE_EXPERIMENTAL_SIMD

// Class template simd [parallel.simd.class]
template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
class simd;

template <class _Tp>
using native_simd = simd<_Tp, simd_abi::native<_Tp>>;

template <class _Tp, int _Np>
using fixed_size_simd = simd<_Tp, simd_abi::fixed_size<_Np>>;

// Class template simd_mask [parallel.simd.mask.class]
template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
class simd_mask;

template <class _Tp>
using native_simd_mask = simd_mask<_Tp, simd_abi::native<_Tp>>;

template <class _Tp, int _Np>
using fixed_size_simd_mask = simd_mask<_Tp, simd_abi::fixed_size<_Np>>;

// Memory alignment
struct element_aligned_tag {
  template <class _Tp, class _Up = typename _Tp::value_type>
  static constexpr size_t __alignment = alignof(_Up);

  template <class _Tp, class _Up>
  static constexpr _Up* __apply(_Up* __ptr) {
    return __ptr;
  }
};

struct vector_aligned_tag {
  template <class _Tp, class _Up = typename _Tp::value_type>
  static constexpr size_t __alignment = sizeof(_Up) * _Tp::size();

  template <class _Tp, class _Up>
  static constexpr _Up* __apply(_Up* __ptr) {
    return static_cast<_Up*>(
	  __builtin_assume_aligned(__ptr, __alignment<_Tp, _Up>));
  }
};

template <size_t _Np>
struct overaligned_tag {
  template <class _Tp, class _Up = typename _Tp::value_type>
  static constexpr size_t __alignment = _Np;

  template <class _Tp, class _Up>
  static constexpr _Up* __apply(_Up* __ptr) {
    return static_cast<_Up*>(
	  __builtin_assume_aligned(__ptr, _Np));
  }
};

inline constexpr element_aligned_tag element_aligned{};

inline constexpr vector_aligned_tag vector_aligned{};

template <size_t _Np>
inline constexpr overaligned_tag<_Np> overaligned{};

// simd type traits [parallel.simd.traits]
template <class _Tp, class = void>
struct __is_abi_tag_impl : std::false_type {};

template <class _Tp>
struct __is_abi_tag_impl<_Tp, std::enable_if_t<_Tp::__is_abi_tag>> : std::bool_constant<_Tp::__is_abi_tag> {};

template <class _Tp>
struct is_abi_tag : __is_abi_tag_impl<_Tp> {};

template <class _Tp>
inline constexpr bool is_abi_tag_v = is_abi_tag<_Tp>::value;

template <class _Tp>
struct is_simd : std::false_type {};

template <class _Tp, class _Abi>
struct is_simd<simd<_Tp, _Abi>> : std::true_type {};

template <class _Tp>
inline constexpr bool is_simd_v = is_simd<_Tp>::value;

template <class _Tp>
struct is_simd_mask : std::false_type {};

template <class _Tp, class _Abi>
struct is_simd_mask<simd_mask<_Tp, _Abi>> : std::true_type {};

template <class _Tp>
inline constexpr bool is_simd_mask_v = is_simd_mask<_Tp>::value;

template <class _Tp>
struct is_simd_flag_type : std::false_type {};

template <>
struct is_simd_flag_type<element_aligned_tag> : std::true_type {};

template <>
struct is_simd_flag_type<vector_aligned_tag> : std::true_type {};

template <size_t _Np>
struct is_simd_flag_type<overaligned_tag<_Np>> : std::true_type {};

template <class _Tp>
inline constexpr bool is_simd_flag_type_v = is_simd_flag_type<_Tp>::value;

template <class _Tp, class _Abi, class = void>
struct __simd_size_impl {};

template <class _Tp, class _Abi>
struct __simd_size_impl<_Tp, _Abi, std::enable_if_t<__is_vectorizable<_Tp>() && is_abi_tag_v<_Abi>>>
    : std::integral_constant<size_t, _Abi::__simd_size> {};

template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
struct simd_size : __simd_size_impl<_Tp, _Abi> {};

template <class _Tp, class _Abi = simd_abi::compatible<_Tp>>
inline constexpr size_t simd_size_v = simd_size<_Tp, _Abi>::value;

template <class _Tp, class _Up, class = void>
struct __memory_alignment_impl {};

template <class _Tp, class _Up>
struct __memory_alignment_impl<_Tp, _Up,
                               std::enable_if_t<(is_simd_v<_Tp> && __is_vectorizable<_Up>()) ||
                                                (is_simd_mask_v<_Tp> && std::is_same_v<_Up, bool>)>>
    : std::integral_constant<size_t, vector_aligned_tag::__alignment<_Tp, _Up>> {};

template <class _Tp, class _Up = typename _Tp::value_type>
struct memory_alignment : __memory_alignment_impl<_Tp, _Up> {};

template <class _Tp, class _Up = typename _Tp::value_type>
inline constexpr size_t memory_alignment_v = memory_alignment<_Tp, _Up>::value;

template <class _Tp, class _Vp, class = void>
struct __rebind_simd_impl {};

template <class _Tp, class _Up, class _Abi>
struct __rebind_simd_impl<_Tp, simd<_Up, _Abi>, void_t<simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>> > {
  using type = simd<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>;
};

template <class _Tp, class _Up, class _Abi>
struct __rebind_simd_impl<_Tp, simd_mask<_Up, _Abi>, void_t<simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>> > {
  using type = simd_mask<_Tp, simd_abi::deduce_t<_Tp, simd_size_v<_Up, _Abi>, _Abi>>;
};

template <class _Tp, class _Vp>
struct rebind_simd : __rebind_simd_impl<_Tp, _Vp> {};

template <class _Tp, class _Vp>
using rebind_simd_t = typename rebind_simd<_Tp, _Vp>::type;

template <int _Np, class _Vp, class = void>
struct __resize_simd_impl {};

template <int _Np, class _Tp, class _Abi>
struct __resize_simd_impl<_Np, simd<_Tp, _Abi>, void_t<simd_abi::deduce_t<_Tp, _Np, _Abi>> > {
  using type = simd<_Tp, simd_abi::deduce_t<_Tp, _Np, _Abi>>;
};

template <int _Np, class _Tp, class _Abi>
struct __resize_simd_impl<_Np, simd_mask<_Tp, _Abi>, void_t<simd_abi::deduce_t<_Tp, _Np, _Abi>> > {
  using type = simd_mask<_Tp, simd_abi::deduce_t<_Tp, _Np, _Abi>>;
};

template <int _Np, class _Vp>
struct resize_simd : __resize_simd_impl<_Np, _Vp> {};

template <int _Np, class _Vp>
using resize_simd_t = typename resize_simd<_Np, _Vp>::type;

// Casts [parallel.simd.casts]
template <class _Tp, class = void>
struct __safe_make_signed {
  using type = _Tp;
};

template <class _Tp>
struct __safe_make_signed<_Tp, std::enable_if_t<is_integral_v<_Tp>>> {
    using type = make_signed_t<_Tp>;
};

template <class _Tp, class _Up, class _Abi, class = void>
struct __static_simd_cast_return_type {};

template <class _Tp, class _Up, class _Abi>
struct __static_simd_cast_return_type<_Tp, _Up, _Abi,
                                      std::enable_if_t<is_simd_v<_Tp> && _Tp::size() == simd<_Up, _Abi>::size()>> {
  using type = _Tp;
};

template <class _Tp, class _Up, class _Abi>
struct __static_simd_cast_return_type<_Tp, _Up, _Abi,
                                      std::enable_if_t<!is_simd_v<_Tp>
                                                       && (is_same_v<_Tp, _Up>
                                                           || is_same_v<__safe_make_signed<_Tp>, __safe_make_signed<_Up>>) >> {
  using type = simd<_Tp, _Abi>;
};

template <class _Tp, class _Up, class _Abi>
struct __static_simd_cast_return_type<_Tp, _Up, _Abi,
                                      std::enable_if_t<!is_simd_v<_Tp> && !is_same_v<_Tp, _Up>
                                                       && !is_same_v<__safe_make_signed<_Up>, __safe_make_signed<_Tp>>>> {
  using type = simd<_Tp, simd_abi::fixed_size<simd<_Up, _Abi>::size()>>;
};

template <class _Tp, class _Up, class _Abi, class = void>
struct __simd_cast_return_type {};

template <class _Tp, class _Up, class _Abi>
struct __simd_cast_return_type<_Tp, _Up, _Abi,
                               std::enable_if_t<is_simd_v<_Tp> && _Tp::size() == simd<_Up, _Abi>::size()
                                                && std::is_convertible<_Up, typename _Tp::value_type>()>> {
  using type = _Tp;
};

template <class _Tp, class _Up, class _Abi>
struct __simd_cast_return_type<_Tp, _Up, _Abi,
                               std::enable_if_t<!is_simd_v<_Tp> && is_same_v<_Tp, _Up>>> {
  using type = simd<_Tp, _Abi>;
};

template <class _Tp, class _Up, class _Abi>
struct __simd_cast_return_type<_Tp, _Up, _Abi,
                               std::enable_if_t<!is_simd_v<_Tp> && !is_same_v<_Tp, _Up>
                                                && std::is_convertible<_Up, _Tp>()>> {
  using type = simd<_Tp, simd_abi::fixed_size<simd<_Up, _Abi>::size()>>;
};

template <class _To, class _From>
std::enable_if_t<is_simd_v<_To> && is_simd_v<_From> && _To::size() == _From::size(), _To>
__simd_conversion(_From __v) { // TODO: Optimizeable
  _To res;
  for (size_t __i = 0; __i < _From::size(); __i++) {
    res[__i] = static_cast<typename _To::value_type>(__v[__i]);
  }
  return res;
}

template <class _To, class _From>
std::enable_if_t<is_simd_mask_v<_To> && is_simd_mask_v<_From> && _To::size() == _From::size(), _To>
__mask_conversion(_From __m) { // TODO: Optimizeable
  _To res;
  for (size_t __i = 0; __i < _From::size(); __i++) {
    res[__i] = __m[__i];
  }
  return res;
}

template <class _Tp, class _Up, class _Abi>
auto simd_cast(const simd<_Up, _Abi>& __v) {
  return __simd_conversion<typename __simd_cast_return_type<_Tp, _Up, _Abi>::type, simd<_Up, _Abi>>(__v);
}

template <class _Tp, class _Up, class _Abi>
auto static_simd_cast(const simd<_Up, _Abi>& __v) {
  return __simd_conversion<typename __static_simd_cast_return_type<_Tp, _Up, _Abi>::type, simd<_Up, _Abi>>(__v);
}

template <class _Tp, class _Abi>
fixed_size_simd<_Tp, simd_size_v<_Tp, _Abi>>
to_fixed_size(const simd<_Tp, _Abi>& __v) noexcept {
  return __simd_conversion<fixed_size_simd<_Tp, simd_size_v<_Tp, _Abi>>, simd<_Tp, _Abi>>(__v);
}

template <class _Tp, class _Abi>
fixed_size_simd_mask<_Tp, simd_size_v<_Tp, _Abi>>
to_fixed_size(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_conversion<fixed_size_simd_mask<_Tp, simd_size_v<_Tp, _Abi>>, simd_mask<_Tp, _Abi>>(__m);
}

template <class _Tp, size_t _Np>
std::enable_if_t<simd_size_v<_Tp, simd_abi::native<_Tp>> == _Np, native_simd<_Tp>>
to_native(const fixed_size_simd<_Tp, _Np>& __v) noexcept {
  return __simd_conversion<native_simd<_Tp>, fixed_size_simd<_Tp, _Np>>(__v);
}

template <class _Tp, size_t _Np>
std::enable_if_t<simd_size_v<_Tp, simd_abi::native<_Tp>> == _Np, native_simd_mask<_Tp>>
to_native(const fixed_size_simd_mask<_Tp, _Np>& __m) noexcept {
  return __mask_conversion<native_simd_mask<_Tp>, fixed_size_simd_mask<_Tp, _Np>>(__m);
}

template <class _Tp, size_t _Np>
std::enable_if_t<simd_size_v<_Tp, simd_abi::compatible<_Tp>> == _Np, simd<_Tp>>
to_compatible(const fixed_size_simd<_Tp, _Np>& __v) noexcept {
  return __simd_conversion<simd<_Tp>, fixed_size_simd<_Tp, _Np>>(__v);
}

template <class _Tp, size_t _Np>
std::enable_if_t<simd_size_v<_Tp, simd_abi::compatible<_Tp>> == _Np, simd_mask<_Tp>>
to_compatible(const fixed_size_simd_mask<_Tp, _Np>& __m) noexcept {
  return __mask_conversion<simd_mask<_Tp>, fixed_size_simd_mask<_Tp, _Np>>(__m);
}

template <class _SimdType, class _Simd>
void __split_assign(const _Simd& __v, _SimdType& __s, size_t& __count) {
  for(size_t __i = 0; __i < __s.size(); __i++)
    __s[__i] = __v[__count++];
}

template <size_t... _Ip, class _Tuple, class _SimdType>
void __split_tuple_impl(const _SimdType& __v, _Tuple& __t, size_t& __count, std::index_sequence<_Ip...>) {
  (__split_assign(__v, std::get<_Ip>(__t), __count), ...);
}

template <size_t... _Sizes, class _Tp, class _Abi>
std::enable_if_t<((_Sizes + ...) == simd_size_v<_Tp,_Abi>), tuple<simd<_Tp, simd_abi::deduce_t<_Tp, _Sizes>>...>>
split(const simd<_Tp, _Abi>& __v) noexcept {
  tuple<simd<_Tp, simd_abi::deduce_t<_Tp, _Sizes>>...> __t;
  size_t __count = 0;
  __split_tuple_impl(__v, __t, __count, std::make_index_sequence<sizeof...(_Sizes)>{});
  return __t;
}

template <size_t... _Sizes, class _Tp, class _Abi>
std::enable_if_t<((_Sizes + ...) == simd_size_v<_Tp,_Abi>), tuple<simd_mask<_Tp, simd_abi::deduce_t<_Tp, _Sizes>>...>>
split(const simd_mask<_Tp, _Abi>& __m) noexcept {
  tuple<simd_mask<_Tp, simd_abi::deduce_t<_Tp, _Sizes>>...> __t;
  size_t __count = 0;
  __split_tuple_impl(__m, __t, __count, std::make_index_sequence<sizeof...(_Sizes)>{});
  return __t;
}

template <class _SimdType, class _Abi>
                                          // FIX ME: Why simd_size_v gives error here?
std::enable_if_t<is_simd_v<_SimdType> && (simd_size<typename _SimdType::value_type, _Abi>::value % _SimdType::size() == 0),
array<_SimdType, simd_size_v<typename _SimdType::value_type, _Abi> / _SimdType::size()>>
split(const simd<typename _SimdType::value_type, _Abi>& __v) noexcept {
  const size_t __size = _SimdType::size();
  array<_SimdType, simd_size_v<typename _SimdType::value_type, _Abi> / __size> __arr{};
  for(size_t __i = 0; __i < __arr.size(); __i++) {
    for(size_t __j = 0; __j < __size; __j++)
      __arr[__i][__j] = __v[__i * __size + __j];
  }
  return __arr;
}

template <class _SimdMaskType, class _Abi>
std::enable_if_t<is_simd_mask_v<_SimdMaskType> && (simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> % _SimdMaskType::size() == 0),
array<_SimdMaskType, simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> / _SimdMaskType::size()>>
split(const simd_mask<typename _SimdMaskType::simd_type::value_type, _Abi>& __m) noexcept {
  const size_t __size = _SimdMaskType::size();
  array<_SimdMaskType, simd_size_v<typename _SimdMaskType::simd_type::value_type, _Abi> / __size> __arr{};
  for(size_t __i = 0; __i < __arr.size(); __i++) {
    for(size_t __j = 0; __j < __size; __j++)
      __arr[__i][__j] = __m[__i * __size + __j];
  }
  return __arr;
}

template<size_t _Num, class _Tp, class _Abi>
std::enable_if_t<simd_size_v<_Tp, _Abi> % _Num == 0,
array<resize_simd<simd_size_v<_Tp, _Abi> / _Num, simd<_Tp, _Abi>>, _Num>>
split_by(const simd<_Tp, _Abi>& __v) noexcept {
  const size_t __size = simd_size_v<_Tp, _Abi> / _Num;
  array<resize_simd<__size, simd<_Tp, _Abi>>, _Num> __arr{};
  for(size_t __i = 0; __i < __arr.size(); __i++) {
    for(size_t __j = 0; __j < __size; __j++)
      __arr[__i][__j] = __v[__i * __size + __j];
  }
  return __arr;
}

template<size_t _Num, class _Tp, class _Abi>
std::enable_if_t<simd_size_v<_Tp, _Abi> % _Num == 0,
array<resize_simd<simd_size_v<_Tp, _Abi> / _Num, simd_mask<_Tp, _Abi>>, _Num>>
split_by(const simd_mask<_Tp, _Abi>& __m) noexcept {
  const size_t __size = simd_size_v<_Tp, _Abi> / _Num;
  array<resize_simd<__size, simd_mask<_Tp, _Abi>>, _Num> __arr{};
  for(size_t __i = 0; __i < __arr.size(); __i++) {
    for(size_t __j = 0; __j < __size; __j++)
      __arr[__i][__j] = __m[__i * __size + __j];
  }
  return __arr;
}

template <class _SimdType, class _Simd>
void __concat_assign(const _Simd& __v, _SimdType& __s, size_t& __count) {
  for(size_t __i = 0; __i < __v.size(); __i++)
    __s[__count++] = __v[__i];
}

template <class _Tp, class... _Abis>
simd<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...)>>
concat(const simd<_Tp, _Abis>&... __v) noexcept {
  simd<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...)>> __res;
  size_t __count = 0;
  (__concat_assign(__v, __res, __count), ...);
  return __res;
}

template <class _Tp, class... _Abis>
simd_mask<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...)>>
concat(const simd_mask<_Tp, _Abis>&... __m) noexcept {
  simd_mask<_Tp, simd_abi::deduce_t<_Tp, (simd_size_v<_Tp, _Abis> + ...)>> __res;
  size_t __count = 0;
  (__concat_assign(__m, __res, __count), ...);
  return __res;
}

template<class _Tp, class _Abi, size_t _Num>
resize_simd<simd_size_v<_Tp, _Abi> * _Num, simd<_Tp, _Abi>>
concat(const array<simd<_Tp, _Abi>, _Num>& __arr) noexcept {
  const size_t __size = simd_size_v<_Tp, _Abi>;
  resize_simd<__size * _Num, simd<_Tp, _Abi>> __s;
  for(size_t __i = 0; __i < _Num; __i++) {
    for(size_t __j = 0; __j < __size; __j++)
      __s[__i * __size + __j] = __arr[__i][__j];
  }
  return __s;
}

template<class _Tp, class _Abi, size_t _Num>
resize_simd<simd_size_v<_Tp, _Abi> * _Num, simd_mask<_Tp, _Abi>>
concat(const array<simd_mask<_Tp, _Abi>, _Num>& __arr) noexcept {
  const size_t __size = simd_size_v<_Tp, _Abi>;
  resize_simd<__size * _Num, simd_mask<_Tp, _Abi>> __m;
  for(size_t __i = 0; __i < _Num; __i++) {
    for(size_t __j = 0; __j < __size; __j++)
      __m[__i * __size + __j] = __arr[__i][__j];
  }
  return __m;
}

// Reductions [parallel.simd.mask.reductions]
template <class _Tp, class _Abi>
bool all_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__all_of(__m.__s_);
}

template <class _Tp, class _Abi>
bool any_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__any_of(__m.__s_);
}

template <class _Tp, class _Abi>
bool none_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__none_of(__m.__s_);
}

template <class _Tp, class _Abi>
bool some_of(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__some_of(__m.__s_);
}

template <class _Tp, class _Abi>
int popcount(const simd_mask<_Tp, _Abi>& __m) noexcept {
  return __mask_traits<_Tp, _Abi>::__popcount(__m.__s_);
}

template <class _Tp, class _Abi>
int find_first_set(const simd_mask<_Tp, _Abi>& __m) {
  return __mask_traits<_Tp, _Abi>::__find_first_set(__m.__s_);
}

template <class _Tp, class _Abi>
int find_last_set(const simd_mask<_Tp, _Abi>& __m) {
  return __mask_traits<_Tp, _Abi>::__find_last_set(__m.__s_);
}

bool all_of(_Bool __v) noexcept { return __v; }

bool any_of(_Bool __v) noexcept { return __v; }

bool none_of(_Bool __v) noexcept { return !__v; }

bool some_of(_Bool) noexcept { return false; }

int popcount(_Bool __v) noexcept { return __v; }

int find_first_set(_Bool) noexcept { return 0; }

int find_last_set(_Bool) noexcept { return 0; }

// Where expression class templates [parallel.simd.whereexpr]
template <class _MaskType, class _SimdType>
class const_where_expression;

template <class _MaskType, class _SimdType>
class where_expression;

// where functions [parallel.simd.mask.where]
template <class _Tp, class _Abi>
where_expression<simd_mask<_Tp, _Abi>, simd<_Tp, _Abi>>
where(const typename simd<_Tp, _Abi>::mask_type& __m, simd<_Tp, _Abi>& __s) noexcept {
  return {__m, __s};
}

template <class _Tp, class _Abi>
const_where_expression<simd_mask<_Tp, _Abi>, simd<_Tp, _Abi>>
where(const typename simd<_Tp, _Abi>::mask_type& __m, const simd<_Tp, _Abi>& __s) noexcept {
  return {__m, __s};
}

template <class _Tp, class _Abi>
where_expression<simd_mask<_Tp, _Abi>, simd_mask<_Tp, _Abi>>
where(const type_identity_t<simd_mask<_Tp, _Abi>>& __m, simd_mask<_Tp, _Abi>& __s) noexcept {
  return {__m, __s};
}

template <class _Tp, class _Abi>
const_where_expression<simd_mask<_Tp, _Abi>, simd_mask<_Tp, _Abi>>
where(const type_identity_t<simd_mask<_Tp, _Abi>>& __m, const simd_mask<_Tp, _Abi>& __s) noexcept {
  return {__m, __s};
}

template <class _Tp>
enable_if_t<!(is_simd_v<_Tp> || is_simd_mask_v<_Tp>), where_expression<bool, _Tp>>
where(_Bool __m, _Tp& __s) noexcept {
  return {__m, __s};
}

template <class _Tp>
enable_if_t<!(is_simd_v<_Tp> || is_simd_mask_v<_Tp>), const_where_expression<bool, _Tp>>
where(_Bool __m, const _Tp& __s) noexcept {
  return {__m, __s};
}

template <typename _Tp, typename _Abi>
void where(bool __m, simd<_Tp, _Abi>& __v) = delete;

template <typename _Tp, typename _Abi>
void where(bool __m, const simd<_Tp, _Abi>& __v) = delete;

// Reductions [parallel.simd.reductions]
template <class _Tp, class _Abi, class _BinaryOp = plus<>>
_Tp reduce(const simd<_Tp, _Abi>& __s, _BinaryOp __binary_op = {}) {
    return __simd_traits<_Tp, _Abi>::__reduce(__s.__s_, __binary_op);
}

template <class _MaskType, class _SimdType, class _BinaryOp>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      typename _SimdType::value_type __identity, _BinaryOp __binary_op) {
  _SimdType __tmp(__w.__s_);
  return _SimdType::_Impl::__reduce(_SimdType::_Impl::__masked_assign(__tmp.__s_, _MaskType::_Impl::__negate(__w.__m_.__s_),
                                    _SimdType::_Impl::__broadcast(__identity)), __binary_op);
}

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      plus<> __binary_op = {}) noexcept {
  return reduce(__w, 0, __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      multiplies<> __binary_op) noexcept {
  return reduce(__w, 1, __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      bit_and<> __binary_op) noexcept {
  return reduce(__w, ~typename _SimdType::value_type(), __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      bit_or<> __binary_op) noexcept {
  return reduce(__w, 0, __binary_op);
};

template <class _MaskType, class _SimdType>
typename _SimdType::value_type reduce(const const_where_expression<_MaskType, _SimdType>& __w,
                                      bit_xor<> __binary_op) noexcept {
  return reduce(__w, 0, __binary_op);
};

template <class _Tp, class _Abi>
_Tp hmin(const simd<_Tp, _Abi>& __s) noexcept {
  return __simd_traits<_Tp, _Abi>::__hmin(__s.__s_);
}

template <class _MaskType, class _SimdType>
typename _SimdType::value_type hmin(const const_where_expression<_MaskType, _SimdType>& __w) noexcept {
  _SimdType __tmp(__w.__s_);
  return _SimdType::_Impl::__hmin(_SimdType::_Impl::__masked_assign(__tmp.__s_, _MaskType::_Impl::__negate(__w.__m_.__s_),
                                  _SimdType::_Impl::__broadcast(numeric_limits<typename _SimdType::value_type>::max())));
};


template <class _Tp, class _Abi>
_Tp hmax(const simd<_Tp, _Abi>& __s) noexcept {
  return __simd_traits<_Tp, _Abi>::__hmax(__s.__s_);
}

template <class _MaskType, class _SimdType>
typename _SimdType::value_type hmax(const const_where_expression<_MaskType, _SimdType>& __w) noexcept {
  _SimdType __tmp(__w.__s_);
  return _SimdType::_Impl::__hmax(_SimdType::_Impl::__masked_assign(__tmp.__s_, _MaskType::_Impl::__negate(__w.__m_.__s_),
                                  _SimdType::_Impl::__broadcast(numeric_limits<typename _SimdType::value_type>::lowest())));
};

// Algorithms [parallel.simd.alg]
template <class _Tp, class _Abi>
simd<_Tp, _Abi> min(const simd<_Tp, _Abi>& __a, const simd<_Tp, _Abi>& __b) noexcept {
  return __simd_traits<_Tp, _Abi>::__min(__a.__s_, __b.__s_);
}

template <class _Tp, class _Abi>
simd<_Tp, _Abi> max(const simd<_Tp, _Abi>& __a, const simd<_Tp, _Abi>& __b) noexcept {
  return __simd_traits<_Tp, _Abi>::__max(__a.__s_, __b.__s_);
}

template <class _Tp, class _Abi>
pair<simd<_Tp, _Abi>, simd<_Tp, _Abi>> minmax(const simd<_Tp, _Abi>& __a, const simd<_Tp, _Abi>& __b) noexcept {
  return __simd_traits<_Tp, _Abi>::__minmax(__a.__s_, __b.__s_);
}

template <class _Tp, class _Abi>
simd<_Tp, _Abi> clamp(const simd<_Tp, _Abi>& __v, const simd<_Tp, _Abi>& __lo, const simd<_Tp, _Abi>& __hi) noexcept{
  return __simd_traits<_Tp, _Abi>::__clamp(__v.__s_, __lo.__s_, __hi.__s_);
}

// Where expression class templates [parallel.simd.whereexpr]
template <class _MaskType, class _SimdType>
class const_where_expression {
  // TODO: check type of _MaskType and _SimdType
  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w) noexcept;

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w) noexcept;

protected:
  using _Impl = typename _SimdType::_Impl;
  const _MaskType __m_;
  _SimdType& __s_;

public:
  const_where_expression(const const_where_expression&) = delete;
  const_where_expression& operator=(const const_where_expression&) = delete;
  const_where_expression(const _MaskType& __m, const _SimdType& s)
    : __m_(__m), __s_(const_cast<_SimdType&>(s)) {}

  _SimdType operator-() const && noexcept { return _Impl::__masked_assign(__s_.__s_, __m_.__s_, _Impl::__unary_minus(__s_.__s_)); }
  _SimdType operator+() const && noexcept { return __s_; }
  _SimdType operator~() const && noexcept { return _Impl::__masked_assign(__s_.__s_, __m_.__s_, _Impl::__bitwise_not(__s_.__s_)); }

  template <class _Up, class _Flags>
  enable_if_t<is_simd_flag_type_v<_Flags> &&
              ((is_same_v<_Up, bool> && is_same_v<typename _SimdType::value_type, bool>) ||
               (__is_vectorizable<_Up>() && !is_same_v<typename _SimdType::value_type, bool>))>
  copy_to(_Up* __mem, _Flags) const && {
    _SimdType __tmp;
    _Impl::__load(__tmp.__s_, _Flags::template __apply<_SimdType>(__mem));
    _Impl::__store(_Impl::__masked_assign(__tmp.__s_, __m_.__s_, __s_.__s_), _Flags::template __apply<_SimdType>(__mem));
  }
};

template <class _Tp>
class const_where_expression<bool, _Tp> {
  // TODO: check type of _Tp
  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w) noexcept;

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w) noexcept;

protected:
  const bool __m_;
  _Tp& __s_;

public:
  const_where_expression(const const_where_expression&) = delete;
  const_where_expression& operator=(const const_where_expression&) = delete;
  const_where_expression(const bool __m, const _Tp& s)
    : __m_(__m), __s_(const_cast<_Tp&>(s)) {}

  _Tp operator-() const && noexcept { return __m_ ? -__s_ : __s_; }
  _Tp operator+() const && noexcept { return __s_; }
  _Tp operator~() const && noexcept { return __m_ ? !__s_ : __s_; }

  template <class _Up, class _Flags>
  enable_if_t<is_simd_flag_type_v<_Flags> &&
              ((is_same_v<_Up, bool> && is_same_v<_Tp, bool>) ||
               (__is_vectorizable<_Up>() && !is_same_v<_Tp, bool>))>
  copy_to(_Up* __mem, _Flags) const && {
    if(__m_)__mem[0] = __m_ ? __s_ : __mem[0];
  };
};


template <class _MaskType, class _SimdType>
class where_expression : public const_where_expression<_MaskType, _SimdType> {
  using _Impl = typename const_where_expression<_MaskType, _SimdType>::_Impl;
  using const_where_expression<_MaskType, _SimdType>::__m_;
  using const_where_expression<_MaskType, _SimdType>::__s_;

public:
  where_expression(const _MaskType& __m, _SimdType& s)
    : const_where_expression<_MaskType, _SimdType>(__m, s){}

  template <class _Up>
  enable_if_t<is_convertible_v<_Up, _SimdType>>
  operator=(_Up&& __v) && noexcept {
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __v.__s_);
  }

#define _LIBCXX_SIMD_MASK_OP_(__op,__name)                                                                       \
  template <class _Up>                                                                                           \
  enable_if_t<is_convertible_v<decltype(declval<_SimdType&>() __op declval<_Up>()), _SimdType>>                  \
  operator __op##=(_Up&& __v) && noexcept {                                                                      \
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, _Impl::__name((__s_.__s_, __v.__s_)));                          \
  }

  _LIBCXX_SIMD_MASK_OP_(+, __plus)
  _LIBCXX_SIMD_MASK_OP_(-, __minus)
  _LIBCXX_SIMD_MASK_OP_(*, __multiplies)
  _LIBCXX_SIMD_MASK_OP_(/, __divides)
  _LIBCXX_SIMD_MASK_OP_(%, __modulus)
  _LIBCXX_SIMD_MASK_OP_(&, __bitwise_and)
  _LIBCXX_SIMD_MASK_OP_(|, __bitwise_or)
  _LIBCXX_SIMD_MASK_OP_(^, __bitwise_xor)
  _LIBCXX_SIMD_MASK_OP_(<<, __shift_left)
  _LIBCXX_SIMD_MASK_OP_(>>, __shift_right)
#undef _LIBCXX_SIMD_MASK_OP_

  template <class _Up = void, class = decltype(++declval<conditional_t<true, _SimdType, _Up>&>())>
  void operator++() && noexcept {
    _SimdType __tmp = __s_;
    _Impl::__increment(__tmp.__s_);
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __tmp.__s_);
  }

  template <class _Up = void, class = decltype(declval<conditional_t<true, _SimdType, _Up>&>()++)>
  void operator++(int) && noexcept {
    _SimdType __tmp = __s_;
    _Impl::__increment(__tmp.__s_);
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __tmp.__s_);
  }

  template <class _Up = void, class = decltype(--declval<conditional_t<true, _SimdType, _Up>&>())>
  void operator--() && noexcept {
    _SimdType __tmp = __s_;
    _Impl::__decrement(__tmp.__s_);
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __tmp.__s_);
  }

  template <class _Up = void, class = decltype(declval<conditional_t<true, _SimdType, _Up>&>()--)>
  void operator--(int) && noexcept {
    _SimdType __tmp = __s_;
    _Impl::__decrement(__tmp.__s_);
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __tmp.__s_);
  }

  template <class _Up, class _Flags>
  enable_if_t<is_simd_flag_type_v<_Flags> &&
              ((is_same_v<_Up, bool> && is_same_v<typename _SimdType::value_type, bool>) ||
               (__is_vectorizable<_Up>() && !is_same_v<typename _SimdType::value_type, bool>))>
  copy_from(const _Up* __mem, _Flags) && {
    _SimdType __tmp;
    _Impl::__load(__tmp.__s_, _Flags::template __apply<_SimdType>(__mem));
    _Impl::__masked_assign(__s_.__s_, __m_.__s_, __tmp.__s_);
  }
};

template <class _Tp>
class where_expression<bool, _Tp> : public const_where_expression<bool, _Tp> {
  using const_where_expression<bool, _Tp>::__m_;
  using const_where_expression<bool, _Tp>::__s_;

public:
  where_expression(const bool __m, _Tp& s)
    : const_where_expression<bool, _Tp>(__m, s){}

template <class _Up>
enable_if_t<is_convertible_v<_Up, _Tp>>
operator=(_Up&& __v) && noexcept {
  __s_ = __m_ ? static_cast<_Up&&>(__v) : __s_;
}

#define _LIBCXX_SIMD_MASK_OP_(__op)                                                                  \
  template <class _Up>                                                                               \
  enable_if_t<is_convertible_v<decltype(declval<_Tp&>() __op declval<_Up>()), _Tp>>                  \
  operator __op##=(_Up&& __v) && noexcept {                                                          \
    __s_ = __m_ ? __s_ __op static_cast<_Up&&>(__v) : __s_;                                          \
  }
  _LIBCXX_SIMD_MASK_OP_(+)
  _LIBCXX_SIMD_MASK_OP_(-)
  _LIBCXX_SIMD_MASK_OP_(*)
  _LIBCXX_SIMD_MASK_OP_(/)
  _LIBCXX_SIMD_MASK_OP_(%)
  _LIBCXX_SIMD_MASK_OP_(&)
  _LIBCXX_SIMD_MASK_OP_(|)
  _LIBCXX_SIMD_MASK_OP_(^)
  _LIBCXX_SIMD_MASK_OP_(<<)
  _LIBCXX_SIMD_MASK_OP_(>>)
#undef _LIBCXX_SIMD_MASK_OP_

  template <class _Up = void, class = decltype(++declval<conditional_t<true, _Tp, _Up>&>())>
  void operator++() && noexcept {
    if(__m_) __s_++;
  }

  template <class _Up = void, class = decltype(declval<conditional_t<true, _Tp, _Up>&>()++)>
  void operator++(int) && noexcept {
    if(__m_) ++__s_;
  }

  template <class _Up = void, class = decltype(--declval<conditional_t<true, _Tp, _Up>&>())>
  void operator--() && noexcept {
    if(__m_) __s_--;
  }

  template <class _Up = void, class = decltype(declval<conditional_t<true, _Tp, _Up>&>()--)>
  void operator--(int) && noexcept {
    if(__m_) --__s_;
  }

  template <class _Up, class _Flags>
  enable_if_t<is_simd_flag_type_v<_Flags> &&
              ((is_same_v<_Up, bool> && is_same_v<_Tp, bool>) ||
               (__is_vectorizable<_Up>() && !is_same_v<_Tp, bool>))>
  copy_from(const _Up* __mem, _Flags) && {
    __s_ = __m_ ? __mem[0] : __s_;
  }
};


// Class template simd [parallel.simd.class]
template <class _Tp, class _Abi>
class simd {
  using _Impl = __simd_traits<_Tp, _Abi>;
  using _Storage = typename _Impl::_Simd;

  _Storage __s_;

  friend class simd_mask<_Tp, _Abi>;

  template <class _MaskType, class _SimdType>
  friend class const_where_expression;

  template <class _MaskType, class _SimdType>
  friend class where_expression;

  friend simd min<>(const simd&, const simd&) noexcept;
  friend simd max<>(const simd&, const simd&) noexcept;
  friend std::pair<simd, simd> minmax<>(const simd&, const simd&) noexcept;
  friend simd clamp<>(const simd&, const simd&, const simd&) noexcept;
  friend _Tp hmin<>(const simd&) noexcept;
  friend _Tp hmax<>(const simd&) noexcept;

  template <class __Tp, class __Abi, class _BinaryOp>
  friend __Tp reduce(const simd<__Tp, __Abi>&, _BinaryOp);

  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w) noexcept;

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w) noexcept;

public:
  using value_type = _Tp;
  using reference = __simd_reference<_Storage, value_type>;
  using mask_type = simd_mask<_Tp, _Abi>;
  using abi_type = _Abi;

  simd() = default;
  simd(const simd&) = default;
  simd& operator=(const simd&) = default;

  simd(_Storage __s) : __s_(__s) {}

  static constexpr size_t size() noexcept { return simd_size_v<value_type, abi_type>; }

  // implicit broadcast constructor
  template <class _Up, std::enable_if_t<__can_broadcast<value_type, _Up>(), int> = 0>
  simd(_Up&& __v) : __s_(_Impl::__broadcast(static_cast<value_type>(__v))) {}

  // implicit type conversion constructor
  template <class _Up, class = std::enable_if_t<std::is_same_v<abi_type, simd_abi::fixed_size<size()>> &&
                                                __is_non_narrowing_arithmetic_convertible<_Up, value_type>()>>
  simd(const simd<_Up, simd_abi::fixed_size<size()>>& __v)
      : simd(static_cast<std::array<_Up, size()>>(__v).data(), vector_aligned) {}

  // generator constructor
  template <class _Generator,
            std::enable_if_t<__can_generate<value_type, _Generator>(std::make_index_sequence<size()>()), int> = 0>
  explicit simd(_Generator&& __g) : __s_(_Impl::__generate(std::forward<_Generator>(__g))) {}

  // load constructor
  template <class _Up, class _Flags, class = std::enable_if_t<__is_vectorizable<_Up>() && is_simd_flag_type_v<_Flags>>>
  simd(const _Up* __mem, _Flags){
    _Impl::__load(__s_, _Flags::template __apply<simd>(__mem));
  }

  // loads [simd.load]
  template <class _Up, class _Flags>
  std::enable_if_t<__is_vectorizable<_Up>() && is_simd_flag_type_v<_Flags>> copy_from(const _Up* __mem, _Flags) {
    _Impl::__load(__s_, _Flags::template __apply<simd>(__mem));
  }

  // stores [simd.store]
  template <class _Up, class _Flags>
  std::enable_if_t<__is_vectorizable<_Up>() && is_simd_flag_type_v<_Flags>> copy_to(_Up* __mem, _Flags) const {
    _Impl::__store(__s_, _Flags::template __apply<simd>(__mem));
  }

  // scalar access [simd.subscr]
  reference operator[](size_t __i) { return reference(__s_, __i); }

  value_type operator[](size_t __i) const { return __s_.__get(__i); }

  // unary operators [simd.unary]
  simd& operator++() noexcept {
    _Impl::__increment(__s_);
    return *this;
  }

  simd operator++(int) noexcept {
    simd __r = *this;
    _Impl::__increment(__s_);
    return __r;
  }

  simd& operator--() noexcept {
    _Impl::__decrement(__s_);
    return *this;
  }

  simd operator--(int) noexcept {
    simd __r = *this;
    _Impl::__decrement(__s_);
    return __r;
  }

  mask_type operator!() const noexcept { return _Impl::__negate(__s_); }

  // TODO: add SFINAE check here
  simd operator~() const noexcept { return _Impl::__bitwise_not(__s_); }

  simd operator+() const noexcept { return *this; }

  simd operator-() const noexcept { return _Impl::__unary_minus(__s_); }

  // binary operators [simd.binary]
  friend simd operator+(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__plus(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator-(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__minus(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator*(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__multiplies(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator/(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__divides(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator%(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__modulus(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator&(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__bitwise_and(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator|(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__bitwise_or(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator^(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__bitwise_xor(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator<<(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__shift_left(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator>>(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__shift_right(__lhs.__s_, __rhs.__s_);
  }

  friend simd operator<<(const simd& __lhs, int __rhs) noexcept { return _Impl::__shift_left(__lhs.__s_, __rhs); }

  friend simd operator>>(const simd& __lhs, int __rhs) noexcept { return _Impl::__shift_right(__lhs.__s_, __rhs); }

  // compound assignment [simd.cassign]
  friend simd& operator+=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs + __rhs; }

  friend simd& operator-=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs - __rhs; }

  friend simd& operator*=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs * __rhs; }

  friend simd& operator/=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs / __rhs; }

  friend simd& operator%=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs % __rhs; }

  friend simd& operator&=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs & __rhs; }

  friend simd& operator|=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs | __rhs; }

  friend simd& operator^=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs ^ __rhs; }

  friend simd& operator<<=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs << __rhs; }

  friend simd& operator>>=(simd& __lhs, const simd& __rhs) noexcept { return __lhs = __lhs >> __rhs; }

  friend simd& operator<<=(simd& __lhs, int __rhs) noexcept { return __lhs = __lhs << __rhs; }

  friend simd& operator>>=(simd& __lhs, int __rhs) noexcept { return __lhs = __lhs >> __rhs; }

  // compares [simd.comparison]
  friend mask_type operator==(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__equal_to(__lhs.__s_, __rhs.__s_);
  }

  friend mask_type operator!=(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__not_equal_to(__lhs.__s_, __rhs.__s_);
  }

  friend mask_type operator>=(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less_equal(__rhs.__s_, __lhs.__s_);
  }

  friend mask_type operator<=(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less_equal(__lhs.__s_, __rhs.__s_);
  }

  friend mask_type operator>(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less(__rhs.__s_, __lhs.__s_);
  }

  friend mask_type operator<(const simd& __lhs, const simd& __rhs) noexcept {
    return _Impl::__less(__lhs.__s_, __rhs.__s_);
  }
};

// Class template simd_mask [parallel.simd.mask.class]
template <class _Tp, class _Abi>
class simd_mask {
  using _Impl = __mask_traits<_Tp, _Abi>;
  using _Storage = typename _Impl::_Mask;

  _Storage __s_;

  friend class simd<_Tp, _Abi>;

  template <class _MaskType, class _SimdType>
  friend class const_where_expression;

  template <class _MaskType, class _SimdType>
  friend class where_expression;

  template <class __Tp, class __Abi, class _BinaryOp>
  friend __Tp reduce(const simd<__Tp, __Abi>&, _BinaryOp);

  template <class _Mp, class _Vp, class _BinaryOp>
  friend typename _Vp::value_type
  reduce(const const_where_expression<_Mp, _Vp>& __w,
         typename _Vp::value_type __identity, _BinaryOp __op);

  friend bool all_of<>(const simd_mask&) noexcept;
  friend bool any_of<>(const simd_mask&) noexcept;
  friend bool none_of<>(const simd_mask&) noexcept;
  friend bool some_of<>(const simd_mask&) noexcept;
  friend int popcount<>(const simd_mask&) noexcept;
  friend int find_first_set<>(const simd_mask&);
  friend int find_last_set<>(const simd_mask&);

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmin(const const_where_expression<_Mp, _Vp>& __w) noexcept;

  template <class _Mp, class _Vp>
  friend typename _Vp::value_type
  hmax(const const_where_expression<_Mp, _Vp>& __w) noexcept;

public:
  using value_type = bool;
  using reference = __simd_reference<_Storage, value_type>;
  using simd_type = simd<_Tp, _Abi>;
  using abi_type = _Abi;

  static constexpr size_t size() noexcept { return simd_type::size(); }

  simd_mask() = default;

  simd_mask(_Storage __s) : __s_(__s) {}

  // broadcast constructor
  explicit simd_mask(value_type __v) noexcept : __s_(_Impl::__broadcast(__v)) {}

  // implicit type conversion constructor
  template <class _Up, class = std::enable_if_t<std::is_same_v<abi_type, simd_abi::fixed_size<size()>> &&
                                                __is_non_narrowing_arithmetic_convertible<_Up, value_type>()>>
  simd_mask(const simd_mask<_Up, simd_abi::fixed_size<size()>>& __v) noexcept
      : simd_mask(static_cast<simd_mask<_Up>>(__v)) {}

  // load constructor
  template <class _Flags, class = std::enable_if_t<is_simd_flag_type_v<_Flags>>>
  simd_mask(const value_type* __mem, _Flags){
    _Impl::__load(__s_, _Flags::template __apply<simd_mask>(__mem));
  }

  // loads [simd.mask.copy]
  template <class _Flags>
  std::enable_if_t<is_simd_flag_type_v<_Flags>> copy_from(const value_type* __mem, _Flags) {
    _Impl::__load(__s_, _Flags::template __apply<simd_mask>(__mem));
  }

  template <class _Flags>
  std::enable_if_t<is_simd_flag_type_v<_Flags>> copy_to(value_type* __mem, _Flags) const {
    _Impl::__store(__s_, _Flags::template __apply<simd_mask>(__mem));
  }

  // scalar access [simd.mask.subscr]
  reference operator[](size_t __i) { return reference(__s_, __i); }

  value_type operator[](size_t __i) const { return __s_.__get(__i); }

  // unary operators [simd.mask.unary]
  simd_mask operator!() const noexcept { return _Impl::__negate(__s_); }

  // simd_mask binary operators [simd.mask.binary]
  friend simd_mask operator&&(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__logical_and(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator||(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__logical_or(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator&(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_and(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator|(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_or(__lhs.__s_, __rhs.__s_);
  }

  friend simd_mask operator^(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_xor(__lhs.__s_, __rhs.__s_);
  }

  // simd_mask compound assignment [simd.mask.cassign]
  friend simd_mask& operator&=(simd_mask& __lhs, const simd_mask& __rhs) noexcept { return __lhs = __lhs & __rhs; }

  friend simd_mask& operator|=(simd_mask& __lhs, const simd_mask& __rhs) noexcept { return __lhs = __lhs | __rhs; }

  friend simd_mask& operator^=(simd_mask& __lhs, const simd_mask& __rhs) noexcept { return __lhs = __lhs ^ __rhs; }

  // simd_mask compares [simd.mask.comparison]
  friend simd_mask operator==(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__negate(_Impl::__bitwise_xor(__lhs.__s_, __rhs.__s_));
  }

  friend simd_mask operator!=(const simd_mask& __lhs, const simd_mask& __rhs) noexcept {
    return _Impl::__bitwise_xor(__lhs.__s_, __rhs.__s_);
  }
};

#endif // _LIBCPP_STD_VER >= 17

_LIBCPP_END_NAMESPACE_EXPERIMENTAL_SIMD

_LIBCPP_POP_MACROS

#endif // _LIBCPP_EXPERIMENTAL_SIMD
